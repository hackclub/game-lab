/*
First time? Check out the tutorial game:
https://sprig.hackclub.com/gallery/getting_started

@title: Circle Run
@author: Bryan Hsu
@tags: [fun]
@addedOn: 2024-00-00
*/

const player = "p"
let timeLeft = 60;  // Set the countdown time (in seconds)
let score = 0;      // Initialize score
let lastMoveTime = 0; // Timestamp of last player move
let lastTimeUpdate = performance.now();  // Time of the last update for the timer

setLegend(
  [ player, bitmap`
................
......3333......
.....333333.....
....3333333.....
...333333333....
..33333333333...
..33333333333...
.333333333333...
.333333333333...
.333333333333...
..3333333333....
....3333333.....
......3333......
................
................
................` ],
  ["o", bitmap`
................
...777777777....
...777777777....
...777777777....
...777777777....
...777777777....
...777777777....
...777777777....
...777777777....
...777777777....
...777777777....
...777777777....
...777777777....
...777777777....
...777777777....
...777777777....`],
  ["a", bitmap`
................
...999999999....
...999999999....
...999999999....
...999999999....
...999999999....
...999999999....
...999999999....
...999999999....
...999999999....
...999999999....
...999999999....
...999999999....
...999999999....
...999999999....
...999999999....`]
)

setSolids([ player, "o", "a" ])

let level = 0
const levels = [
  map`
................
................
................
................
................
................
................
................
................
................
................
................
................
................
..............p.
................`
]

setMap(levels[level])

setPushables({
  [ player ]: []
})

function canMove() {
  return performance.now() - lastMoveTime > 1000;  // 1000 milliseconds = 1 second
}

onInput("s", () => {
  if (canMove()) {
    getFirst(player).y += 1
    lastMoveTime = performance.now()  // Update last move timestamp
  }
})

onInput("w", () => {
  if (canMove()) {
    getFirst(player).y -= 1
    lastMoveTime = performance.now()
  }
})

onInput("a", () => {
  if (canMove()) {
    getFirst(player).x -= 1
    lastMoveTime = performance.now()
  }
})

onInput("d", () => {
  if (canMove()) {
    getFirst(player).x += 1
    lastMoveTime = performance.now()
  }
})

afterInput(() => {
  // Update the timer based on performance.now()
  const currentTime = performance.now();
  const elapsedTime = Math.floor((currentTime - lastTimeUpdate) / 1000);  // Elapsed time in seconds
  if (elapsedTime >= 1) {  // Update every second
    timeLeft -= elapsedTime;
    lastTimeUpdate = currentTime;  // Update the last time the timer was changed
  }

  // Show game over if time is up
  if (timeLeft <= 0) {
    addText(`Game Over! Score: ${score}`, { x: 5, y: 5, color: color`3` })
  } else {
    // Update and display the timer and score
    addText(`Time Left: ${timeLeft}s`, { x: 0, y: 0, color: color`4` })
    addText(`Score: ${score}`, { x: 10, y: 10, color: color`5` })
  }
})

// Spawn moving obstacles
function spawnObstacles() {
  addSprite(15, Math.floor(Math.random() * 10), "o")  // Add obstacle at random Y position
  let obstacle = getFirst("o")
  obstacle.x -= 3  // Move the obstacle faster (3 spaces per tick)
  
  if (obstacle.x <= 0) {
    obstacle.remove()
  }
}

// Spawn apples to collect
function spawnApples() {
  if (Math.random() < 0.1) {  // 10% chance to spawn an apple
    addSprite(15, Math.floor(Math.random() * 10), "a")  // Random Y position
  }
}

// Check if player collects an apple
function checkAppleCollection() {
  getAll("a").forEach(apple => {
    if (apple.x === getFirst(player).x && apple.y === getFirst(player).y) {
      apple.remove()  // Remove apple from the screen
      score += 10     // Increase score when apple is collected
    }
  })
}

// Spawn obstacles and apples every 2 seconds
setInterval(spawnObstacles, 1000)
setInterval(spawnApples, 1000)

// Collision detection and apple collection check
afterInput(() => {
  // Check if player collides with an obstacle
  if (getAll("o").some(obstacle => obstacle.x === getFirst(player).x && obstacle.y === getFirst(player).y)) {
    addText(`Game Over! Score: ${score}`, { x: 5, y: 5, color: color`3` })
    timeLeft = 0  // Stop the game
  }

  // Check for apple collection
  checkAppleCollection()
})
